\section{Shortest Path Algorithm}

Working with DWRGs the SPP is not well defined.
An exact solution cannot be computed on a random graph since it depends on the specific observed instance.
In this section, an algorithm consisting of two phases will be presented.

\subsection{Static Phase}

The static phase will solve a modified version of the ASSP\footnote{All Sources Shortest Path} problem.

Inspired by The Floyd-Warshall\cite{cormen2010introduction} algorithm\footnote{$d_{ij}^{(k)}$ represents the weight of the shortest path from vertex $i$ to vertex $j$ for which all intermediate vertices belong to the set \{1, 2, \dots, k\}. $d_{ikj}^{(k-1)} = d_{ik}^{(k-1)} + d_{kj}^{(k-1)}$}
\begin{equation*}
	d_{ij}^{(k)} = 
	\begin{cases}
		w_{ij} & \text{if k = 0} \\
		\min\{d_{ij}^{(k-1)}, d_{ikj}^{(k-1)}\} & \text{otherwise}
	\end{cases}
\end{equation*}
the distance estimates will be computed.
In the proposed framework the pattern is slightly different: $d_{ij}^{(k)}$ is a random variable that is built as follow
\begin{equation*}
	d_{ij}^{(k)} = 
	\begin{cases}
		w_{ij} \text{ \ \ \ if k = 0} \\
		d_{ij}^{(k-1)} \text{ if } P(d_{ij}^{(k-1)} < d_{ikj}^{(k-1)}) \geq 0.5 \\
		d_{ikj}^{(k-1)} \text{ otherwise}
	\end{cases}
\end{equation*}
In the Jupyter Notebook an iterative\footnote{While a recursive formula is easier to read, an iterative algorithm is more efficient.} version of the algorithm will be implemented.
%show how to compute the less probability
\subsection{Dynamic Phase}
show a short pseudocode for the dynamic part (maybe also just the formula that computes the probabilities).

Be $D_{i,j}$ the matrix of extimation computed during the static phase and let $G_{sample}$ a sample of the DRWG $G$. 


\begin{algorithm}
	\caption{Greedy Dynamic} 
    Input: $s$ source node, $t$ terminal node, $G_{sample} = (V,A)$, $D_{i,j}$.  \\
    Output: shortest path $P$ from $s$ to $t$.
	\begin{algorithmic}[1]
        \State $P \gets \{s\}$
        \State $current \gets s$
        \While {$current \neq t$}
            \State Let $N_{current} \gets \{n \in V \mid n \text{ is a neighbor of } current \text{ and not visited}\}$
            \State $E \gets \emptyset$
            \For {$n \in N_{current}$}
                \If {$n = t$}
                    \State $E \gets E \cup \{(n, w_{current,n})\}$
                \Else
                    \State $E \gets E \cup \{(n, w_{current,n} + \mathbb{E}[D_{n,t}])\}$
                \EndIf
            \EndFor
            \State $current \gets \arg\min_{(n,w) \in E} w$
            \State Mark $current$ as visited
            \State $P \gets P \cup \{current\}$
        \EndWhile
        \State \Return $P$
	\end{algorithmic} 
\end{algorithm}
